use r2api::structs::LSectionInfo;
use petgraph::graph::NodeIndex;

use frontend::radeco_containers::{RadecoFunction, RadecoModule};
use middle::ir::MOpcode;
use middle::ssa::ssastorage::{SSAStorage};
use middle::ssa::ssa_traits::SSA;
use middle::ssa::ssa_traits::SSAWalk;
use middle::ssa::ssa_traits::{NodeType, NodeData};
use middle::regfile::SubRegisterFile;

use std::collections::HashSet;


pub struct FuncArgumentAnalyzer<'a> {
    registers: &'a SubRegisterFile,
    sections: &'a [LSectionInfo],
    arguments: Vec<NodeIndex>
}

pub struct FuncInfo {
    arguments: Vec<NodeIndex>
}

/// Argument filters define what is semantically important as an argument
/// and what is not. For example, in x86, the "ret" opcode turns into the
/// following SSA form:
///
/// $2 (rip) = Load(mem, rsp)
/// $3 (rsp) = $1 (rsp) + 0x08
///
/// In this case note that ret pops the value of the return address into the
/// rip register and then decreases the stack size by the size of the address.
///
/// While [rsp] is technically an argument in this case, it holds the value
/// of the return address. Conventionally, this is an implicit argument 
/// generated by the compiler. Every function invocation will have it and it
/// is not necessarily important. These sort of arguments may vary on an
/// architecture to architecture, and compiler to compiler basis, so this trait
/// allows for generic filtering to remove un-important arguments.
pub trait ArgumentFilter {
    fn is_important(ssa: &SSAStorage, ni: NodeIndex) -> bool;
}

/// Let's every argument through, no filtering applies
struct NoArgumentFilter;
impl ArgumentFilter for NoArgumentFilter {
    fn is_important(_ssa: &SSAStorage, _ni: NodeIndex) -> bool {
        true
    }
}

struct X86ArgumentFilter;
impl ArgumentFilter for X86ArgumentFilter {
    fn is_important(ssa: &SSAStorage, ni: NodeIndex) -> bool {
        let nd = ssa.node_data(ni).unwrap();
        let operands = ssa.operands_of(ni);

        let dst_registers = ssa.registers(ni);

        // rax is conventionally used as at the return value register
        if dst_registers.len() == 1 && dst_registers[0] == "rax" {
            return false;
        }

        match nd.nt {
            NodeType::Op(ref opc) => {
                match opc {
                    &MOpcode::OpLoad => {
                        // Ignore anything that loads a value into rip, this is usually
                        // the "ret" instruction popping the return address from the stack
                        // and we don't treat the return address as an explicit argument
                        if dst_registers.len() == 1 && dst_registers[0] == "rip" {
                            return false;
                        }
                    },
                    &MOpcode::OpAdd | &MOpcode::OpSub => {
                        // Ignore instructions that extend or shrink the stack, these look
                        // like rsp = rsp + 0x32 or rsp = rsp - 0x8 etc. While technically
                        // the original stack pointer is an argument to the function, we
                        // will not consider it to be one.
                        if dst_registers.len() == 1 && dst_registers[0] == "rsp" {
                            return false;
                        }
                    }
                    _ => ()
                };
            },
            _ => ()
        }

        true
    }
}

impl<'a> FuncArgumentAnalyzer<'a> {
    pub fn new(registers: &'a SubRegisterFile, sections: &'a [LSectionInfo]) -> FuncArgumentAnalyzer<'a> {
        return FuncArgumentAnalyzer {
            registers, sections, arguments: Vec::new()
        };
    }

    pub fn determine_arguments(&self, f: &mut RadecoFunction) -> FuncInfo {
        self.determine_arguments_filter::<X86ArgumentFilter>(f)
    }

    pub fn determine_arguments_filter<T: ArgumentFilter>(&self, f: &mut RadecoFunction) -> FuncInfo {
        println!("Parsing new function: {}", f.name);

        if f.name != "sym._init" {
            let mut arguments = Vec::new();
            return FuncInfo { arguments };
        }

        let ssa = f.ssa();

        let mut arguments = Vec::new();
        let mut tainted = HashSet::new();

        for idx in ssa.inorder_walk() {
            let nd = ssa.node_data(idx);
            if nd.is_err() {
                continue;
            }
            let nd = nd.unwrap();

            if (!T::is_important(ssa, idx)) {
                continue;
            }

            let operands = ssa.operands_of(idx);
            for op in operands.iter() {
                for reg in ssa.registers(*op) {
                    let reg = reg;
                    if (!tainted.contains(&reg)) {
                        arguments.push(*op);
                    }
                    tainted.insert(reg);
                }
            }

            tainted.extend(ssa.registers(idx));
            
            println!("{:?} {:?} {:?} {:?}", idx, nd.nt, nd, ssa.registers(idx));
            for (i, op) in operands.iter().enumerate() {
                println!("  arg {}: {:?} {:?} {:?}", i, *op, ssa.node_data(*op).unwrap(), ssa.registers(*op));
            }
        }

        for arg in arguments.iter() {
            println!("Argument: {:?}, {:?}", arg, ssa.registers(*arg));
        }

        println!(" ");

        
        return FuncInfo { arguments };
    }
} 